# Build and publish documentation for all versions + latest.
# Run manually when you want to rebuild docs without re-running the full release pipeline.
# Uses the same cache key as release.yml so cached book/ from releases can be reused.

name: Build and publish docs

permissions:
  contents: read
  pages: write
  id-token: write

on:
  workflow_dispatch: {}

env:
  MDBOOK_VERSION: "0.5.2"

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
          cache: 'pip'
          cache-dependency-path: scripts/requirements.txt

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements.txt

      - name: Install Rust (for mdbook when not cached)
        uses: dtolnay/rust-toolchain@stable

      - name: Cache mdbook
        id: cache-mdbook
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/mdbook
          key: ${{ runner.os }}-mdbook-${{ env.MDBOOK_VERSION }}
          restore-keys: |
            ${{ runner.os }}-mdbook-

      - name: Install mdbook
        if: steps.cache-mdbook.outputs.cache-hit != 'true'
        run: cargo install mdbook --version ${{ env.MDBOOK_VERSION }} --locked --force

      - name: Compute docs cache key
        id: compute-docs-key
        run: |
          VERSION_SHA=$(git tag -l "v*" | sort -V | while read t; do echo "$t:$(git rev-parse "$t")"; done | sha256sum | cut -c1-16)
          echo "version_sha=$VERSION_SHA" >> "$GITHUB_OUTPUT"

      - name: Restore docs cache
        uses: actions/cache@v4
        with:
          path: book
          key: docs-book-${{ runner.os }}-${{ steps.compute-docs-key.outputs.version_sha }}
          restore-keys: |
            docs-book-${{ runner.os }}-

      - name: Build tag documentation (skip if cached for same SHA)
        run: |
          ORIGINAL_COMMIT=$(git rev-parse HEAD)
          ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          [ -f scripts/docs/build_single_version_docs.py ] || (echo "Error: scripts/docs/build_single_version_docs.py not found" && exit 1)
          [ -f scripts/docs/rebuild_index.py ] || (echo "Error: scripts/docs/rebuild_index.py not found" && exit 1)
          [ -f scripts/docs/index.html.j2 ] || (echo "Error: scripts/docs/index.html.j2 not found" && exit 1)
          SCRIPT_DIR="/tmp/datui-build-scripts-$$"
          mkdir -p "$SCRIPT_DIR"
          cp scripts/docs/build_single_version_docs.py "$SCRIPT_DIR/"
          cp scripts/docs/rebuild_index.py "$SCRIPT_DIR/"
          cp scripts/docs/index.html.j2 "$SCRIPT_DIR/"
          mkdir -p book
          rm -rf book/demos
          VERSION_TAGS=$(git tag -l "v*" | sort -V)
          for tag in $VERSION_TAGS; do
            TAG_SHA=$(git rev-parse "$tag")
            if [ -f "book/$tag/.built_sha" ] && [ "$(cat "book/$tag/.built_sha")" = "$TAG_SHA" ]; then
              echo "Skipping $tag (already built for this SHA)"
            else
              python3 "$SCRIPT_DIR/build_single_version_docs.py" "$tag" || true
              echo "$TAG_SHA" > "book/$tag/.built_sha"
            fi
            git checkout "$ORIGINAL_COMMIT" 2>/dev/null || git checkout "$ORIGINAL_BRANCH" 2>/dev/null || git checkout main 2>/dev/null
          done
          CURRENT_COMMIT=$(git rev-parse HEAD)
          [ "$CURRENT_COMMIT" != "$ORIGINAL_COMMIT" ] && git checkout "$ORIGINAL_COMMIT"
          rm -rf "$SCRIPT_DIR"
          python3 scripts/docs/rebuild_index.py

      - name: Copy latest release to latest
        run: |
          LATEST_TAG=$(git tag -l "v*" | sort -V | tail -1)
          if [ -z "$LATEST_TAG" ]; then
            echo "::warning::No version tags found; skipping book/latest"
          else
            rm -rf book/latest
            cp -r "book/$LATEST_TAG" book/latest
            echo "Set book/latest -> $LATEST_TAG"
          fi

      - name: Prepare Pages artifact
        run: |
          cp -r book book-deploy
          find book-deploy -name .built_sha -delete

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./book-deploy

  deploy-pages:
    runs-on: ubuntu-latest
    needs: [build-docs]
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      pages: write
      id-token: write
    steps:
      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
